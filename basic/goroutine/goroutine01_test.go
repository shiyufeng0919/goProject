package goroutine

import (
	"fmt"
	"runtime"
	"testing"
	"time"
)

/*
goroutine协程和channel管道

1,进程和线程
1),进程就是程序在操作系统中的一次执行过程，是系统进行资源分配和调度的基本单位
如：微信就是一个进程
2),线程是进程的一个执行实例，是程序执行的最小单元，它是比进程更小能独立运行的基本单位
如：每个聊天窗口
3),一个进程可以创建和销毁多个线程，同一个进程中的多个线程可以并发执行
4),一个程序至少有一个进程,一个进程至少有一个线程

2,并发和并行
1),并发：多线程程序在「单核」上运行
因为是在一个CPU上，如10个线程，每个线程执行10ms(进行轮询操作)，从人的角度看，好像这10个线程都在运行，
但从微观上看，在某一个时间点看，其实只有一个线程在执行，这就是并发。

2),并行：多线程程序在「多核」上运行
因为是在多个CPU上(如：10个CPU)，比如有10个线程，每个线程执行10ms(各自在不同cpu上执行),从人的角度看，这10个线程都在运行，
但从微观上看，在某一个时间点看，也同时有10个线程在执行，这就是并行.

			 Task01
CPU1 <-------Task02    并发特点：多个任务作用在一个CPU
			 Task03            从微观角度看，在一个时间点上，其实只有一个任务在执行
			    |
                | GO设计(让所有闲置CPU都参与工作，可将任务交给多个CPU执行)
			    ^
CPU1 <-------Task01
CPU2 <-------Task02    并行特点：多个任务作用在多个CPU
CPU3 <-------Task03            从微观角度看，在一个时间点上，就是有多个任务在执行


3,Go协程和Go主线程
1),Go主线程(可称为线程/也可理解为进程)即一个Go线程上，可以起多个协程，协程是轻量级的线程(编译器做优化)

2),GO协程的特点
1),有独立的栈空间
2),共享程序堆空间
3),调度由用户控制
4),协程是轻量级的线程

        启动N个协程
Go主线程	 ------->	协程1(goroutine)
		 ------->	协程2(goroutine)
					......
		 ------->	协程N(goroutine): 理论上，在主线程上启上万个协程都没有问题!

结论:
1),主线程是一个物理线程，直接作用在cpu上的，是重量级的，非常耗费cpu资源. (主线程由操作系统来控制)
2),协程是从主线程开启的，是轻量级的线程，是逻辑态的，对资源消耗相对较小
3),golang的协程机制是重要的特点，可以轻松的开启上万个协程，其它编程语言的并发机制一般基本线程，开启过多的线程，资源消费大。这里就突显了golang在并发上的优势.

4,MPG模式
M：操作系统的主线程(是物理线程)
P：协程执行需要的上下文(上下文：它是一个相对抽象的概念，即它需要的资源或它运行时的一个状态。就像人一样，有空气有水才能生活)
G：协程
1),MPG模式运行的状态1
M1 					M2						M3
P1	---G1			P2 ---G1				P3	---G1
	   G2			      G2					   G2
	   G3			      G3
G1				    G2						G3
说明：
A,当前程序有3个M(Main主线程)，若3个M都在一个cpu运行，就是并发，若在不同的cpu运行就是并行
B,M1,M2,M3正在执行一个G,M1的协程队列有3个,M2的协程队列有3个，M3的协程队列有2个
C,上图可看到，Go的协程是轻量级的线程，是逻辑态的，Go可以容易的起上万个协程。
D,其它程序c/java的多线程，往往是内核态的，比较重量级，几千个线程可能耗光cpu.
2),MPG模式运行的状态2
当有协程被阻塞时，有一种切换机制，既能够M主线程的执行，也能够让排队的G协程得到运行的一种机制(可参考documents/尚硅谷_韩顺平_Go语言核心编程.pdf)

5,设置golang运行的cpu数
介绍：为了充分利用多cpu优势，在go程序中，设置运行的cpu数目
说明：go1.8后，默认让程序运行在多个核上，可以不用设置了
     go1.8前，需要设置，可更高效的利用cpu

package runtime
runtime包提供和go运行时环境的互操作，如控制go程的函数。它也包括用于reflect包的低层次类型信息；参见reflect报的文档获取运行时类型系统的可编程接口。
*/

func TestGoroutine01(t *testing.T) {
	//goroutine入门案例
	goroutine11()
	//设置cpu数
	goroutine12()
}

func goroutine11() {
	/*
			程序开始(进程/主线程开始执行)
			     |
			go helloWord()开启协程    ----
				 |						 |
		     主线程这里for循环执行        协程这里for循环执行
									   1)若主线程退出了，则协程即使还没有执行完毕，也会退出
									   2)协程也可以在主线程没有退出前，就自已结束了，如完成了自已的任务
			     |
			主线程退出(程序退出)
	*/
	go helloWord() //使用go开启了一个协程,在执行helloWord()方法同时，不影响下述业务的执行!!!
	for i := 0; i < 4; i++ {
		fmt.Println(fmt.Sprintf("hi syf %v", i))
		time.Sleep(time.Second)
	}
}

func goroutine12() {
	cpuNum := runtime.NumCPU()
	fmt.Println("goroutine12===\ncpuNum:", cpuNum) //cpuNum: 8
	//可自行设置使用多少个cpu
	//GOMAXPROCS设置可同时执行的最大CPU数，并返回先前的设置。 若 n < 1，它就不会更改当前设置。本地机器的逻辑CPU数可通过 NumCPU 查询
	useCpu := runtime.GOMAXPROCS(2)
	fmt.Println("useCpu:", useCpu) //始终显示8
}

func helloWord() {
	for i := 0; i < 100; i++ {
		fmt.Println(fmt.Sprintf("hello world %v", i))
		time.Sleep(time.Second)
	}
}
