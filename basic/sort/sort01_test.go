package sort

import (
	"fmt"
	"testing"
)

/*
排序和查找

排序的分类:
1,内部排序
指将需要处理的所有数据都加载到内部存储器中进行排序
包括: 交换式排序、选择式排序、插入式排序
1）交换式排序
是运用数据值比较后，依判断规则对数据位置进行交换，以达到排序目的。
交换式排序分2种：
A,冒泡排序法(Bubble sort) ***
基本思想:

B,快速排序法(Quick sort)

2,外部排序
数据量过大，无法全部加载到内存中，需要借助外部存储进行排序。
包括：合并排序法、直接合并排序法
*/

func TestSort01(t *testing.T){
	//冒泡排序,从小 -> 大 示例
	sort11()
}

func sort11(){
	/*
	 [80,60,90,10,20]
	第1轮:          !  ! ->比较一次，向后移动一个,两两比较
		第1次比较: [60,80,90,10,20] //80和60比,80>60,交换
		第2次比较: [60,80,90,10,20] //指针向后移1位，指向上述80和90,80<90,不交换
		第3次比较: [60,80,10,90,20] //指针向后移1位,指向上述90和10,90>10,交换
		第3次比较: [60,80,10,20,90] //指针向后移1位,指向上述90和20,90>20交换，此时最大数90已确认
	[60,80,10,20,90]
	第2轮:
				   ！ ！
		第1次比较: [60,80,10,20,90]
		第2次比较: [60,10,80,20,90]
		第3次比较: [60,10,20,80,90] //此时80 90已确认
	[60,10,20,80,90]
	第3轮:
		第1次比较: [10,60,20,80,90]
		第2次比较: [10,20,60,80,90] //此时60 80 90已确认
	[10,20,60,80,90]
	第4轮:
		第1次比较: [10,20,60,80,90]

	冒泡排序规则：
	1，一共会经过array.length-1次的轮数比较，每一轮将会确定一个数的位置。
	2，每一轮的比较次数在逐渐减少。【4,3,2,1】
	3，当发现前面一个数比后面一个数大时，就进行交换。
	*/
	/*
	思路: 先将最大的数放到最后；再将第二大的数放到倒数第2; ....规律...
	*/
	var array [5]int = [5]int{80,60,90,10,20}
	bubbleSort1(&array)
	bubbleSort2(&array)
}

//冒泡排序，因为数组是值类型，为了修改数组值，需要传递指针.
func bubbleSort1(arr *[5]int){
	fmt.Printf("\n BubbleSort1排序前arr:%+v",arr) //[80 60 90 10 20]
	//完成第一轮排序
	temp := 0
	for i:=0 ; i<len(arr) -1 ; i++ {
		if (*arr)[i] > (*arr)[i + 1] { //第一个数和第二个数比较
			temp = (*arr)[i]
			(*arr)[i] = (*arr)[i + 1]
			(*arr)[i + 1] = temp
		}
	}
	fmt.Printf("\n 第1轮 BubbleSort1排序后arr:%+v",arr) //[60 80 10 20 90]

	//完成第二轮排序
	for i:=0 ; i<len(arr) -2 ; i++ {
		if (*arr)[i] > (*arr)[i + 1] {
			temp = (*arr)[i]
			(*arr)[i] = (*arr)[i + 1]
			(*arr)[i + 1] = temp
		}
	}
	fmt.Printf("\n 第2轮 BubbleSort1排序后arr:%+v",arr) //[60 10 20 80 90]

	//完成第三轮排序
	for i:=0 ; i<len(arr) -3 ; i++ {
		if (*arr)[i] > (*arr)[i + 1] {
			temp = (*arr)[i]
			(*arr)[i] = (*arr)[i + 1]
			(*arr)[i + 1] = temp
		}
	}
	fmt.Printf("\n 第3轮 BubbleSort1排序后arr:%+v",arr) //[10 20 60 80 90]
	//完成第四轮排序
	for i:=0 ; i<len(arr) -4 ; i++ {
		if (*arr)[i] > (*arr)[i + 1] {
			temp = (*arr)[i]
			(*arr)[i] = (*arr)[i + 1]
			(*arr)[i + 1] = temp
		}
	}
	fmt.Printf("\n 第4轮 BubbleSort1排序后arr:%+v",arr) //[10 20 60 80 90]
}

func bubbleSort2(arr *[5]int){
	fmt.Printf("\n BubbleSort2排序前arr:%+v",arr) //[80 60 90 10 20]
	temp := 0
	for j:=0 ; j< len(arr) -1; j++ {
		for i:=0 ; i<len(arr) -1 - j ; i++ {
			if (*arr)[i] > (*arr)[i + 1] {
				temp = (*arr)[i]
				(*arr)[i] = (*arr)[i + 1]
				(*arr)[i + 1] = temp
			}
		}
	}
	fmt.Printf("\n 第1轮 BubbleSort2排序后arr:%+v",arr) //[10 20 60 80 90]
}
